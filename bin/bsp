#!/usr/bin/env python

"""bsp: Runs BlueSky

Example calls:
 > ./bin/bsp.py -i fires-before.json -o fires-after.json
 > cat fires-before.json | ./bin/bsp.py > fires-after.json
 > ./bin/bsp.py < fires-before.json > fires-after.json
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright 2015, AirFire, PNW, USFS"

import json
import importlib
import logging
import pkgutil
import sys
import traceback
import argparse

from pyairfire import scripting

try:
    from bluesky import modules, models
except:
    import os
    root_dir = os.path.abspath(os.path.join(sys.path[0], '../'))
    sys.path.insert(0, root_dir)
    from bluesky import modules, models

class ParseFormatAction(argparse.Action):

    def __call__(self, parser, namespace, values, option_string=None):
        value = values.strip()
        try:
            setattr(namespace, self.dest, models.fires.FireDataFormats[value])
        except models.fires.FireDataFormatNotSupported:
            msg = "Invalid fire data format: %s" % (values)
            raise argparse.ArgumentError(msg)

# Note: though some argue that all required parameters should be specified as
# positional arguments, I prefer using 'options' flags, even though this
# means that there are required 'options', which is oxymoronic.

REQUIRED_OPTIONS = []

OPTIONAL_OPTIONS = [
    {
        'short': '-l',
        'long': '--list-modules',
        'dest': 'list_modules',
        'help': 'lists available modules; order matters',
        'action': "store_true",
        'default': False
    },
    {
        'short': '-c',
        'long': '--config-file',
        'dest': 'config_file',
        'help': 'config file comtaining overrides for default config values',
        'action': "store",
        'default': None
    },
    {
        'short': '-i',
        'long': '--input-file',
        'dest': 'input_file',
        'help': 'input file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'short': '-o',
        'long': '--output-file',
        'dest': 'output_file',
        'help': 'output file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'long': '--input-format',
        'dest': 'input_format',
        'help': 'format of input fire data; valid formats: %s; default: json' % (
            ', '.join(models.fires.FireDataFormats.formats)),
        'action': ParseFormatAction,
        'default': models.fires.FireDataFormats.json
    },
    {
        'long': '--output-format',
        'dest': 'output_format',
        'type': str,
        'help': 'format to output fire data; valid formats: %s; default: json' % (
            ', '.join(models.fires.FireDataFormats.formats)),
        'action': ParseFormatAction,
        'default': models.fires.FireDataFormats.json
    },
    {
        'short': '-w',
        'long': '--country-code-whitelist',
        'dest': 'country_code_whitelist',
        'help': 'input file comtaining JSON formatted fire data',
        'action': "append",
        'default': []
    },
    {
        'short': "-D",
        'long': '--config-option',
        'dest': 'config_options',
        'help': "Config option override, formatted like 'Section.Option=value'",
        'action': scripting.args.SetConfigOptionAction
    }
]

POSITIONAL_ARGS = [
    {
        'long': 'modules',
        'nargs': '*'
    }
]

# Note: pkgutil.walk_packages recursively walks modules and packages, while
# pkgutil.iter_modules iterates through only modules and packages that are
# one deep
AVAILABLE_MODULES = [
    #p[1].split('.')[-1] for p in pkgutil.iter_modules(modules.__path__, modules.__name__ + '.') #if p[2]
    p[1] for p in pkgutil.iter_modules(modules.__path__)
]

def validate_options(options):
    # TODO: validate options values as necessary
    pass

def main():
    # TODO: figure out way to include available modules in help message,
    # and then remove '--list-modules' option
    def pre_validation(parser, options):
        if options.list_modules:
            scripting.utils.exit_with_msg(
                "Available Modules:\n\t%s" % ('\n\t'.join(AVAILABLE_MODULES)),
                #extra_preceeding_output=lambda: parser.print_help(),
                exit_code=0, prefix="")

    parser, options = scripting.args.parse_args(REQUIRED_OPTIONS,
        OPTIONAL_OPTIONS, positional_args=POSITIONAL_ARGS,
        usage="usage: %(prog)s [options] [<module> ...]",
        pre_validation=pre_validation)

    validate_options(options)

    scripting.utils.log_config(options.config_options)

    try:
        modules = [
            importlib.import_module('bluesky.modules.%s' % (m)) for m in options.modules
        ]
    except ImportError, e:
        scripting.utils.exit_with_msg(e.message,
            extra_output=lambda: parser.print_help())

    try:
        fires_importer = models.fires.FiresImporter(
            options.input_file, options.output_file)
        fires_importer.loads(options.input_format)

        if options.country_code_whitelist:
            fires_importer.filter('country', option.country_code_whitelist)

        for module in modules:
            # TDOO: catch any exception raised by a module and dumps
            # whatever is the current state of fires (or state of fires prior
            # to calling hte module) ?
            # 'run' modifies fires in place
            module.run(fires_importer.fires, options.config_options)

        fires_importer.dumps(options.output_format)

    except Exception, e:
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            scripting.utils.exit_with_msg(traceback.format_exc(), prefix="")
        else:
            scripting.utils.exit_with_msg(e.message)

if __name__ == "__main__":
    main()
