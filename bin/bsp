#!/usr/bin/env python

"""bsp: Runs BlueSky

Example calls:
 > bsp -i fires-before.json -o fires-after.json
 > cat fires-before.json | bsp > fires-after.json
 > bsp < fires-before.json > fires-after.json
"""

__author__      = "Joel Dubowy"
__copyright__   = "Copyright 2015, AirFire, PNW, USFS"

import json
import importlib
import logging
import pkgutil
import sys
import traceback
import argparse

from pyairfire import scripting

try:
    from bluesky import exceptions, configuration, modules, models, process, __version__
except:
    import os
    root_dir = os.path.abspath(os.path.join(sys.path[0], '../'))
    sys.path.insert(0, root_dir)
    from bluesky import exceptions, configuration, modules, models, process, __version__

REQUIRED_ARGS = []

OPTIONAL_ARGS = [
    {
        'short': '-i',
        'long': '--input-file',
        'dest': 'input_file',
        'help': 'input file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'short': '-o',
        'long': '--output-file',
        'dest': 'output_file',
        'help': 'output file comtaining JSON formatted fire data',
        'action': "store",
        'default': None
    },
    {
        'short': '-w',
        'long': '--country-code-whitelist',
        'dest': 'country_code_whitelist',
        'help': 'input file comtaining JSON formatted fire data',
        'action': "append",
        'default': []
    },
    # If we resurrect loading config settings from file, consider accepting json,
    # instead of or in addition to ConfigParser ini format, in order to accept
    # values other than just strings (e.g. numeric values)
    # {
    #     'short': '-c',
    #     'long': '--config-file',
    #     'dest': 'config_file',
    #     'help': 'config file comtaining overrides for default config values',
    #     'action': "store",
    #     'default': None
    # },
    # {
    #     'short': "-D",
    #     'long': '--config-option',
    #     'dest': 'config_options',
    #     'help': "Config option override, formatted like 'Section.Option=value'",
    #     'action': scripting.args.SetConfigOptionAction
    # },
    {
        #'short': "-v",
        'long': '--version',
        'dest': 'version',
        'action': 'store_true',
        'help': "Output bluesky version and exit.",
        'default': False
    }
]

POSITIONAL_ARGS = [
    {
        'long': 'module',
        'nargs': '*'
    }
]

# Note: pkgutil.walk_packages recursively walks modules and packages, while
# pkgutil.iter_modules iterates through only modules and packages that are
# one deep
AVAILABLE_MODULES = [
    #p[1].split('.')[-1] for p in pkgutil.iter_modules(modules.__path__, modules.__name__ + '.') #if p[2]
    p[1] for p in pkgutil.iter_modules(modules.__path__)
]
# Note: the trailing space seems to be the only way to add an extra trailing line
AVAILABLE_MODULES_STR = """\
Available Modules:
    {}
 """.format('\n    '.join(AVAILABLE_MODULES))

def validate_args(args):
    # TODO: validate args values as necessary
    pass

def exit_with_traceback(e):
    logging.error(e)
    logging.debug(traceback.format_exc())
    scripting.utils.exit_with_msg(e)

def output_version(parser, args):
    if args.version:
        sys.stdout.write("bsp (bluesky) version {}\n".format(__version__))
        sys.exit(0)

def load_fires(args):
    # Note: Calling code handles exception
    fires_manager = models.fires.FiresManager()
    fires_manager.loads(input_file=args.input_file)

    if args.country_code_whitelist:
        fires_manager.filter('country', args.country_code_whitelist)
    return fires_manager

def main():
    parser, args = scripting.args.parse_args(REQUIRED_ARGS, OPTIONAL_ARGS,
        positional_args=POSITIONAL_ARGS, epilog=AVAILABLE_MODULES_STR,
        pre_validation=output_version)
    validate_args(args)
    #scripting.utils.log_config(args.config_options)

    try:
        fires_manager = load_fires(args)
        config = configuration.config_parser_from_dict(fires_manager.config or {})
        # TODO: uncomment/enable '-D'/'--contig-option' and merge the config
        # values specified in args.config_options into config. It may be easier
        # to refactor that option to produce nested dict rather than a
        # ConfigParser object.  Make sure output json contains merged config
        process.run_modules(args.module, fires_manager, config)
    except exceptions.BlueSkyModuleError, e:
        # The error was added to fires_manager's meta data, and will be
        # included in the output data
        pass
    except Exception, e:
        exit_with_traceback(e)

    fires_manager.dumps(output_file=args.output_file)

if __name__ == "__main__":
    main()
